import socket
import subprocess
import nmap
import requests
import threading
import queue
import time
from typing import Dict, List, Optional, Callable
import re
import ssl
from OpenSSL import SSL, crypto
from datetime import datetime
import sys
from urllib.parse import urljoin
import concurrent.futures

class VulnerabilityScanner:
    def __init__(self, target_url: str, max_threads: int = 10):
        self.target_url = target_url.rstrip('/')
        self.max_threads = max_threads
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.results = []
        self.start_time = None
        self.end_time = None

    def scan(self, callback: Optional[Callable] = None) -> List[Dict]:
        """Perform a comprehensive vulnerability scan of the target URL."""
        self.start_time = datetime.now()
        self.results = []

        # Perform all vulnerability checks
        checks = [
            self.check_http_methods,
            self.check_common_directories,
            self.check_server_info,
            self.check_ssl_tls,
            self.check_common_vulnerabilities,
            self.check_cors,
            self.check_csrf
        ]

        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            futures = [executor.submit(check, callback) for check in checks]
            concurrent.futures.wait(futures)

        self.end_time = datetime.now()
        return self.results

    def check_http_methods(self, callback: Optional[Callable] = None):
        """Check for potentially dangerous HTTP methods."""
        methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD', 'TRACE', 'CONNECT']
        allowed_methods = []

        try:
            response = requests.options(self.target_url)
            if 'Allow' in response.headers:
                allowed_methods = response.headers['Allow'].split(', ')
            
            for method in methods:
                if method in allowed_methods:
                    if method in ['PUT', 'DELETE', 'TRACE']:
                        result = {
                            'type': 'HTTP Method',
                            'severity': 'Medium',
                            'description': f'Potentially dangerous HTTP method {method} is allowed',
                            'details': f'The server allows the {method} method which could be used for malicious purposes'
                        }
                        self.results.append(result)
                        if callback:
                            callback(result)
        except Exception as e:
            if callback:
                callback({'error': f'Error checking HTTP methods: {str(e)}'})

    def check_common_directories(self, callback: Optional[Callable] = None):
        """Check for common sensitive directories."""
        common_dirs = [
            '/admin', '/backup', '/config', '/database', '/logs',
            '/phpmyadmin', '/server-status', '/wp-admin', '/.git',
            '/.env', '/.htaccess', '/.htpasswd'
        ]

        for directory in common_dirs:
            try:
                url = urljoin(self.target_url, directory)
                response = self.session.get(url, timeout=5)
                
                if response.status_code in [200, 301, 302, 403]:
                    result = {
                        'type': 'Sensitive Directory',
                        'severity': 'High',
                        'description': f'Sensitive directory found: {directory}',
                        'details': f'The directory {directory} is accessible (Status: {response.status_code})'
                    }
                    self.results.append(result)
                    if callback:
                        callback(result)
            except Exception:
                continue

    def check_server_info(self, callback: Optional[Callable] = None):
        """Check for server information disclosure."""
        try:
            response = self.session.get(self.target_url)
            headers = response.headers

            # Check for server information in headers
            if 'Server' in headers:
                result = {
                    'type': 'Server Information',
                    'severity': 'Low',
                    'description': 'Server information disclosure',
                    'details': f'Server header reveals: {headers["Server"]}'
                }
                self.results.append(result)
                if callback:
                    callback(result)

            # Check for X-Powered-By header
            if 'X-Powered-By' in headers:
                result = {
                    'type': 'Server Information',
                    'severity': 'Low',
                    'description': 'Server technology disclosure',
                    'details': f'X-Powered-By header reveals: {headers["X-Powered-By"]}'
                }
                self.results.append(result)
                if callback:
                    callback(result)

        except Exception as e:
            if callback:
                callback({'error': f'Error checking server information: {str(e)}'})

    def check_ssl_tls(self, callback: Optional[Callable] = None):
        """Check SSL/TLS configuration."""
        try:
            hostname = self.target_url.split('://')[1].split('/')[0]
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if (not_after - datetime.now()).days < 30:
                        result = {
                            'type': 'SSL/TLS',
                            'severity': 'Medium',
                            'description': 'SSL certificate expiring soon',
                            'details': f'Certificate expires on {not_after.strftime("%Y-%m-%d")}'
                        }
                        self.results.append(result)
                        if callback:
                            callback(result)

                    # Check for weak protocols
                    if 'TLSv1' in ssock.version():
                        result = {
                            'type': 'SSL/TLS',
                            'severity': 'High',
                            'description': 'Weak TLS protocol detected',
                            'details': f'Server supports {ssock.version()} which may be vulnerable'
                        }
                        self.results.append(result)
                        if callback:
                            callback(result)

        except Exception as e:
            if callback:
                callback({'error': f'Error checking SSL/TLS: {str(e)}'})

    def check_common_vulnerabilities(self, callback: Optional[Callable] = None):
        """Check for common web vulnerabilities."""
        # SQL Injection test
        sql_payloads = ["' OR '1'='1", "' OR 1=1 --", "admin' --"]
        for payload in sql_payloads:
            try:
                response = self.session.get(f"{self.target_url}?id={payload}")
                if any(error in response.text.lower() for error in ['sql', 'mysql', 'syntax error']):
                    result = {
                        'type': 'SQL Injection',
                        'severity': 'High',
                        'description': 'Potential SQL Injection vulnerability',
                        'details': f'Server responded to SQL injection payload: {payload}'
                    }
                    self.results.append(result)
                    if callback:
                        callback(result)
            except Exception:
                continue

        # XSS test
        xss_payloads = ['<script>alert(1)</script>', '<img src=x onerror=alert(1)>']
        for payload in xss_payloads:
            try:
                response = self.session.get(f"{self.target_url}?q={payload}")
                if payload in response.text:
                    result = {
                        'type': 'XSS',
                        'severity': 'High',
                        'description': 'Potential XSS vulnerability',
                        'details': f'Server reflected XSS payload: {payload}'
                    }
                    self.results.append(result)
                    if callback:
                        callback(result)
            except Exception:
                continue

    def check_cors(self, callback: Optional[Callable] = None):
        """Check for CORS misconfiguration."""
        try:
            headers = {
                'Origin': 'https://malicious.com',
                'Access-Control-Request-Method': 'GET'
            }
            response = self.session.options(self.target_url, headers=headers)
            
            if 'Access-Control-Allow-Origin' in response.headers:
                if response.headers['Access-Control-Allow-Origin'] == '*':
                    result = {
                        'type': 'CORS',
                        'severity': 'Medium',
                        'description': 'Insecure CORS configuration',
                        'details': 'Server allows requests from any origin (*)'
                    }
                    self.results.append(result)
                    if callback:
                        callback(result)
        except Exception as e:
            if callback:
                callback({'error': f'Error checking CORS: {str(e)}'})

    def check_csrf(self, callback: Optional[Callable] = None):
        """Check for CSRF protection."""
        try:
            response = self.session.get(self.target_url)
            if 'csrf' not in response.text.lower() and 'token' not in response.text.lower():
                result = {
                    'type': 'CSRF',
                    'severity': 'Medium',
                    'description': 'Potential CSRF vulnerability',
                    'details': 'No CSRF token found in forms'
                }
                self.results.append(result)
                if callback:
                    callback(result)
        except Exception as e:
            if callback:
                callback({'error': f'Error checking CSRF: {str(e)}'})

    def get_scan_duration(self) -> float:
        """Get the duration of the scan in seconds."""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        return 0.0 